<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>RideCam - Turn your Phone into a Dash Camera</title>
<meta name="description" content="Turn your Phone into a Dash Cam">

<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">

<style>
body {
  margin:0; background:#000; color:#fff; font-family:Arial;
  height:100vh; overflow:hidden;
  position:relative;
}

/* NAVIGATION */
nav {
  width:100%;
  background:#111;
  padding:12px;
  text-align:center;
  position:fixed;
  top:0; left:0;
  z-index:5;
}
nav button {
  background:#222;
  border:1px solid #444;
  padding:10px 16px;
  color:white;
  margin:0 6px;
  border-radius:8px;
  font-size:18px;
  cursor:pointer;
}
nav button.active {
  background:#007bff;
}

/* MAIN WRAPPER */
#appPages {
  position:absolute;
  top:60px;
  left:0;
  width:100%;
  height:calc(100vh - 60px);
  overflow:hidden;
}

/* DASHCAM PAGE */
#dashcamPage {
  width:100%;
  height:100%;
  position:relative;
  display:flex;
  justify-content:center;
  align-items:center;
  text-align:center;
  overflow:hidden;
}

#preview {
  position:absolute;
  top:0; left:0;
  width:100%; height:100%;
  display:none;
  background:#111;
  z-index:1;
  object-fit:cover;
}

canvas {
  position: absolute;
  top:0;
  left:0;
  z-index:2;
  pointer-events:none;
}

#description {
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  width:85%;
  font-size:22px;
  text-align:center;
  z-index:3;
  line-height:1.4em;
}

.center-start {
  position:absolute;
  top:65%;
  left:50%;
  transform:translate(-50%, -50%);
  z-index:3;
}

button {
  padding:18px 26px;
  font-size:22px;
  border:none;
  border-radius:12px;
  background:#28a745;
  color:#fff;
  cursor:pointer;
}

/* START BUTTON (100% LARGER) */
#startBtn {
  padding:36px 52px;
  font-size:44px;
}

/* CONTROLS */
.controls {
  position: absolute;
  bottom: 36%;
  left: 50%;
  transform: translateX(-50%);
  display: none;
  gap: 16px;
  z-index: 4;
}

.controls button {
  padding:28px 44px;
  font-size:clamp(28px, 8vw, 40px);
  border-radius:16px;
}

#saveBtn { background:#007bff; color:white; }
#stopBtn { background:#dc3545; color:white; }

/* SAVE NOTICE */
#saveNotice {
  display: none;
  position: absolute;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  width: auto;           /* let the width shrink to fit text */
  max-width: 90%;        /* but not exceed 90% of screen */
  padding: 8px 12px;     /* optional, gives space around text */
  text-align: center;
  font-size: 12px;
  z-index: 999;
  text-shadow: 0 0 8px #000;
  color: white;
  white-space: normal; 
  word-wrap: break-word; 
  line-height: 1.3em;    /* prevent lines from overlapping */
  box-sizing: border-box;
}

/* NEW: SAVE CONFIRMATION POPUP */
#savedPopup {
  display:none;
  position:absolute;
  top:40%;
  width:100%;
  text-align:center;
  font-size:26px;
  color:#0f0;
  text-shadow:0 0 10px #000;
  z-index:999;
}

/* OTHER PAGES */
.page {
  display:none;
  padding:20px;
  overflow-y:auto;
  height:100%;
}

h1 {
  text-align:center;
  margin-top:10px;
}

.faq-item {
  margin-bottom:20px;
}

.faq-item h3 {
  margin-bottom:6px;
  color:#0af;
}

/* MOBILE */
@media(max-width:480px){
  .controls button, button{
    padding:10px 16px;
    font-size:14px;
  }
  #description { font-size:18px; }
}
</style>
</head>

<body>

<!-- NAV BAR -->
<nav>
  <button id="navDashcam" class="active">DashCam</button>
  <button id="navFAQ">FAQ</button>
  <button id="navAbout">About</button>
  <button id="navLegal">Legal</button>
  <button id="navDonations">Donations</button>
</nav>

<div id="appPages">

  <!-- DASHCAM PAGE -->
  <div id="dashcamPage" class="page" style="display:block;">
    <div id="description">
      This camera will save up to the last 5 minutes of video,<br>
      press Start to begin.
    </div>

    <button id="startBtn" class="center-start">Start</button>

    <video id="preview" autoplay playsinline muted></video>

    <div id="saveNotice">
      Recording 20 more seconds before saving. Press STOP to finish early.
    </div>

    <!-- NEW: VIDEO SAVED POPUP -->
    <div id="savedPopup">Video saved!</div>

    <div id="controls" class="controls">
      <button id="saveBtn" class="control-btn">Save Video</button>
      <button id="stopBtn" class="control-btn">Stop</button>
    </div>
  </div>

  <!-- FAQ -->
  <!-- (unchanged, same as your file) -->
  <div id="faqPage" class="page">
    <h1>FAQ</h1>
    <div class="faq-item">
      <h3>How does this work?</h3>
      <p>
        Click Start when you're ready to start your drive.<br>
        The camera keeps the last 5 minutes.<br>
        When something happens, press <b>Save Video</b>.
      </p>
    </div>

    <div class="faq-item">
      <h3>What file format does it save in?</h3>
      <p>The camera saves in Webmedia format which is the easiest, most reliable, and optimal in terms of size for this application. You can convert the file using online resources. </p>
    </div>
      <div class="faq-item">
      <h3>What about IOS?</h3>
      <p>Good question! You'll have to find a way to convert it to view it on IOS, but the file should be viewable on other browsers. Best of Luck! </p>
    </div>

    <div class="faq-item">
      <h3>Why do you need camera access?</h3>
      <p>To function as a dash cam, camera access is required.</p>
    </div>

    <div class="faq-item">
      <h3>Do you store anything?</h3>
      <p>No. Everything stays on your device.</p>
    </div>

    <div class="faq-item">
      <h3>Why location access?</h3>
      <p>It’s used to calculate driving speed.</p>
    </div>

    <div class="faq-item">
      <h3>Screen off?</h3>
      <p>No, the camera must stay active.</p>
    </div>

    <div class="faq-item">
      <h3>How am I doing?</h3>
      <p>Great! Thanks for asking.</p>
    </div>
  </div>

  <!-- ABOUT -->
  <div id="aboutPage" class="page">
    <h1>About RideCam.ca</h1>
    <p>
      Ridecam.ca lets you use your phone as a Dash Camera. For any inquiries, feedback, or just to say hi email us at ridecam.ca@gmail.com
    </p>
    <p>
      100% free. No data collection.<br>
      All video stays on your device.
    </p>
  </div>

  <!-- LEGAL -->
  <div id="legalPage" class="page">
    <h1>Legal Notice</h1>
    <p>Legal & Liability Notice: RideCam provides general information and tools for personal dashcam use. All recordings, storage, and use of video captured through this site are the sole responsibility of the user. You are responsible for complying with all local, provincial/state, and federal laws regarding privacy, data collection, and the use of recording devices. RideCam makes no guarantees regarding the accuracy, reliability, or legality of recordings made using our service and is not liable for any damages, losses, or legal issues arising from the use or misuse of the dashcam features.
Use of this site constitutes acceptance of these terms.</p>
    <h3>Safe Use</h3>
    <p>
      • Only use the camera when safe.<br>
      • Never interact while driving.<br>
      • Follow all laws.
    </p>

    <h3>No Liability</h3>
    <p>Use at your own risk.</p>

    <h3>No Warranty</h3>
    <p>Provided “as-is”.</p>
  </div>

  <!-- DONATIONS -->
  <div id="donationsPage" class="page">
    <h1>Support RideCam</h1>
    <p>
      RideCam.ca is 100% free and has no ads.<br>
      You can donate below if you'd like to support development.
    </p>

    <script async src="https://js.stripe.com/v3/buy-button.js"></script>

<stripe-buy-button
  buy-button-id="buy_btn_1SYtSBLRKVOKcZZ1gFQfvk3V"
  publishable-key="pk_live_6At8Xa6cO7izid0cDO3u8GfH"
>
</stripe-buy-button>
  </div>

</div>

<script>
/* ---------- PAGE NAVIGATION ---------- */
const pages = {
  dashcam: document.getElementById("dashcamPage"),
  faq: document.getElementById("faqPage"),
  about: document.getElementById("aboutPage"),
  legal: document.getElementById("legalPage"),
  donations: document.getElementById("donationsPage")
};
const navButtons = {
  dashcam: document.getElementById("navDashcam"),
  faq: document.getElementById("navFAQ"),
  about: document.getElementById("navAbout"),
  legal: document.getElementById("navLegal"),
  donations: document.getElementById("navDonations")
};

function showPage(page) {
  Object.values(pages).forEach(p => p.style.display = "none");
  Object.values(navButtons).forEach(b => b.classList.remove("active"));
  pages[page].style.display = "block";
  navButtons[page].classList.add("active");
  if (page !== "dashcam") stopCamera();
}

navButtons.dashcam.onclick = () => showPage("dashcam");
navButtons.faq.onclick = () => showPage("faq");
navButtons.about.onclick = () => showPage("about");
navButtons.legal.onclick = () => showPage("legal");
navButtons.donations.onclick = () => showPage("donations");

/* ---------- DASHCAM FUNCTIONALITY ---------- */
let stream, recorder;
let buffer = [];
const maxChunks = 60;
const preview = document.getElementById("preview");
const startBtn = document.getElementById("startBtn");
const controls = document.getElementById("controls");
const saveBtn = document.getElementById("saveBtn");
const stopBtn = document.getElementById("stopBtn");
const description = document.getElementById("description");
const saveNotice = document.getElementById("saveNotice");

/* NEW */
const savedPopup = document.getElementById("savedPopup");

let mimeType = "";
let drawing = false;
let savingInProgress = false;
let saveTimeout = null;

const overlayCanvas = document.createElement("canvas");
overlayCanvas.style.display = "none";
document.body.appendChild(overlayCanvas);
const ctx = overlayCanvas.getContext("2d");

/* --- SPEEDOMETER VARS --- */
let speedKmh = 0;
let lastPos = null;
let lastTime = null;

/* ---------- CANVAS RESIZE ---------- */
function resizeCanvas() {
  const rect = preview.getBoundingClientRect();
  const width = rect.width || window.innerWidth;
  const height = rect.height || (window.innerHeight - 60);
  overlayCanvas.width = width;
  overlayCanvas.height = height;
  overlayCanvas.style.left = rect.left + "px";
  overlayCanvas.style.top = rect.top + "px";
  overlayCanvas.style.width = width + "px";
  overlayCanvas.style.height = height + "px";
}

preview.addEventListener("loadedmetadata", () => setTimeout(resizeCanvas, 120));
window.addEventListener("resize", () => setTimeout(resizeCanvas, 120));
window.addEventListener("orientationchange", () => setTimeout(resizeCanvas, 250));

/* ---------- DRAW OVERLAY ---------- */
function drawOverlay() {
  if (!drawing) return;

  ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
  ctx.drawImage(preview, 0, 0, overlayCanvas.width, overlayCanvas.height);

  const topMenuHeight = 60;
  const safeTop = parseInt(getComputedStyle(document.documentElement)
                     .getPropertyValue("env(safe-area-inset-top)")) || 0;

  const bottomControlsHeight = overlayCanvas.height * 0.36 + 50; 

  const baseFontSize = Math.max(16, overlayCanvas.width * 0.04) * 0.5;
  ctx.font = `${baseFontSize}px Arial`;
  ctx.fillStyle = "yellow";
  ctx.textBaseline = "top";

  const dateText = new Date().toLocaleString();
  const speedText = `Speed: ${speedKmh.toFixed(1)} km/h`;

  const dateWidth = ctx.measureText(dateText).width;
  const speedWidth = ctx.measureText(speedText).width;
  const centerX = overlayCanvas.width / 2;

  const minY = topMenuHeight + safeTop + 10;
  const maxY = overlayCanvas.height - bottomControlsHeight - baseFontSize*2 - 10;
  const yPos = Math.min(minY, maxY);

  ctx.fillText(dateText, centerX - dateWidth/2, yPos);
  ctx.fillText(speedText, centerX - speedWidth/2, yPos + baseFontSize + 4);

  /* ---------- WATERMARK — ENLARGED 400% ---------- */
  ctx.font = `${baseFontSize * 1.6 * 4}px Arial`;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.textBaseline = "bottom";
  const watermark = "Ridecam.ca";
  const wmWidth = ctx.measureText(watermark).width;
  const wmX = (overlayCanvas.width / 2) - (wmWidth / 2);
  const wmY = overlayCanvas.height - 40;
  ctx.fillText(watermark, wmX, wmY);

  requestAnimationFrame(drawOverlay);
}

/* ---------- SPEED TRACKING ---------- */
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3;
    const toRad = x => x * Math.PI / 180;

    const φ1 = toRad(lat1);
    const φ2 = toRad(lat2);
    const Δφ = toRad(lat2 - lat1);
    const Δλ = toRad(lon2 - lon1);

    const a = Math.sin(Δφ/2)**2 +
              Math.cos(φ1)*Math.cos(φ2) *
              Math.sin(Δλ/2)**2;

    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function updateSpeed(position) {
    const { latitude, longitude } = position.coords;
    const now = position.timestamp;

    if (lastPos && lastTime) {
        const dist = calculateDistance(lastPos.lat, lastPos.lon, latitude, longitude);
        const timeDiff = (now - lastTime) / 1000;

        if (timeDiff > 0) {
            const speedMs = dist / timeDiff;
            speedKmh = speedMs * 3.6;
        }
    }

    lastPos = { lat: latitude, lon: longitude };
    lastTime = now;
}

navigator.geolocation.watchPosition(updateSpeed, console.error, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 5000
});

/* ---------- SAVE POPUP FUNCTION ---------- */
function showSavedPopup() {
  savedPopup.style.display = "block";
  setTimeout(() => savedPopup.style.display = "none", 4000);
}

let preloadedStream = null;

// Preload camera and ask for permissions
async function preloadCamera() {
  try {
    preloadedStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" },
      audio: false
    });

    // Show preview in hidden mode to initialize camera
    preview.srcObject = preloadedStream;
    preview.style.display = "none";

  } catch (err) {
    console.warn("Camera preload failed:", err);
  }
}

// Preload location permission
let watchId = null;
function preloadLocation() {
  if (navigator.geolocation) {
    watchId = navigator.geolocation.watchPosition(
      updateSpeed,
      console.error,
      { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
    );
  }
}

// Call these on page load
preloadCamera();
preloadLocation();

/* ---------- START RECORDING ---------- */
async function startRecording() {
  try {
    mimeType = pickMimeType();
   if (!preloadedStream) {
  // fallback if preload failed
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode:"environment" },
    audio: false
  });
} else {
  stream = preloadedStream;
}

    preview.srcObject = stream;
    preview.style.display = "block";
    startBtn.style.display = "none";
    description.style.display = "none";
    controls.style.display = "flex";
    overlayCanvas.style.display = "block";
    setTimeout(resizeCanvas, 200);

    drawing = true;
    drawOverlay();

    const combinedStream = overlayCanvas.captureStream(30);
    stream.getTracks().forEach(t => combinedStream.addTrack(t));

    buffer = [];
    recorder = new MediaRecorder(combinedStream, { mimeType });

    recorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        buffer.push(e.data);
        if (buffer.length > maxChunks) buffer.shift();
      }
    };

    recorder.start(500);

  } catch (err) {
    alert("Camera access failed. Try tapping Start again.\n" + err);
  }
}

function pickMimeType() {
  const options = [
    "video/webm;codecs=vp9",
    "video/webm;codecs=vp8",
    "video/webm",
    "video/mp4"
  ];
  for (let type of options) {
    if (MediaRecorder.isTypeSupported(type)) return type;
  }
  return "video/webm"; // fallback
}

/* ---------- STOP CAMERA ---------- */
function stopCamera() {
  try {
    if (recorder && recorder.state !== "inactive") {
      recorder.stop();
    }
  } catch(e){}

  // Stop tracks only if it's a new recording
  if (stream && stream !== preloadedStream) {
    stream.getTracks().forEach(t => t.stop());
  }

  preview.srcObject = preloadedStream; // keep preview ready
  preview.style.display = "none";
  overlayCanvas.style.display = "none";
  drawing = false;

  saveNotice.style.display = "none";
  controls.style.display = "none";
  startBtn.style.display = "block";      // <-- returns to start
  description.style.display = "block";   // <-- shows description

  savingInProgress = false;
  buffer = [];
}
/* ---------- SAVE VIDEO ---------- */
// Save video button
function saveVideo() {
  if (savingInProgress) return;
  savingInProgress = true;

  saveNotice.innerText =
    "Saving Video";
  saveNotice.style.display = "block";

  // Copy last 30 seconds of buffer (maxChunks)
  const bufferCopy = buffer.slice();

  const extraChunks = [];
  const onExtraData = (e) => {
    if (e.data.size > 0) extraChunks.push(e.data);
  };

  recorder.addEventListener("dataavailable", onExtraData);

  saveTimeout = setTimeout(() => {
    recorder.removeEventListener("dataavailable", onExtraData);

    const allChunks = bufferCopy.concat(extraChunks);
    const blob = new Blob(allChunks, { type: mimeType });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "ridecam_" + new Date().toISOString().replace(/[:.]/g, "-") + ".webm";
    a.click();

    showSavedPopup();
    saveNotice.style.display = "none";
    savingInProgress = false;

    if (stopRequestedDuringSave) {
      stopRequestedDuringSave = false;
      stopCamera();
    }

  }, 5000);
}
/* ---------- FINISH SAVING ---------- */
function finishSaving() {
  saveNotice.style.display = "none";

  // Copy current buffer to avoid modifying it during ongoing recording
  const bufferCopy = buffer.slice();

  // Create and download blob from copied buffer
  const blob = new Blob(bufferCopy, { type: mimeType });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "ridecam_" + new Date().toISOString().replace(/[:.]/g, "-") + ".webm";
  a.click();

  showSavedPopup();

  savingInProgress = false;

  // If the user pressed STOP while saving, handle it
  if (stopRequestedDuringSave) {
    stopRequestedDuringSave = false;
    stopCamera();
  }
}

// Track if STOP was pressed during saving
let stopRequestedDuringSave = false;
stopBtn.onclick = () => {
  if (savingInProgress) {
    clearTimeout(saveTimeout);
    finishSaving();
    stopRequestedDuringSave = true;
  } else {
    stopCamera();
  }
};

/* ---------- BUTTON EVENTS ---------- */
startBtn.onclick = startRecording;
saveBtn.onclick = saveVideo;
/* ---------- STOP BUTTON ---------- */
stopBtn.onclick = () => {
  // Stop recording and return to start screen
  stopCamera();
};
</script>
</body>
</html>
